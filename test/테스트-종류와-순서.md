#Test

# 테스트 종류와 순서

## 테스트 종류와 순서 알아보기

### 1. 단위 테스트 (Unit Test)

가장 작고 기본적인 테스트입니다. 개별 함수, 메서드, 컴포넌트 등 코드의 **최소 단위**가 의도한 대로 정확하게 작동하는지 검증합니다.

- **특징**:
  - 다른 부분에 의존하지 않고 독립적으로 실행됩니다.
  - 테스트 실행 속도가 가장 빠릅니다.
  - 버그의 위치를 정확히 파악하기 쉽습니다.
- **예시**: 특정 함수가 숫자를 더하는지, 유효성 검사 함수가 올바른 결과를 반환하는지 확인합니다.

### 2. 통합 테스트 (Integration Test)

단위 테스트를 통과한 여러 모듈이나 컴포넌트들이 **서로 연동될 때** 올바르게 동작하는지 확인하는 테스트입니다.

- **특징**:
  - 각 모듈 간의 인터페이스, 데이터 전달, 상호작용에 초점을 맞춥니다.
  - 단위 테스트보다 더 넓은 범위를 다룹니다.
- **예시**: 로그인 모듈과 사용자 관리 모듈이 연동되어 사용자가 성공적으로 로그인하는지 확인합니다.

### 3. E2E 테스트 (End-to-End Test)

애플리케이션을 **사용자 관점**에서 처음부터 끝까지 테스트하는 과정입니다.

- **특징**:
  - 실제 사용자가 사용하는 것과 같은 환경에서 웹 브라우저, 데이터베이스, 서버 등 **모든 구성요소**를 포함하여 테스트합니다.
  - 사용자의 주요 시나리오(로그인, 게시글 작성, 결제 등)를 검증합니다.
  - 테스트 실행 속도가 가장 느립니다.
- **예시**: 사용자가 회원가입, 로그인, 상품 주문을 완료하는 전체 과정을 자동화하여 테스트합니다.

### 4. 인수 테스트 (Acceptance Test)

소프트웨어가 **비즈니스 요구사항**과 사용자의 기대를 충족하는지 확인하는 테스트입니다.

- **특징**:
  - 개발팀이 아닌 사용자 또는 비즈니스 관계자가 주도하여 수행할 수도 있습니다.
  - E2E 테스트와 유사한 관점을 가지지만, 비즈니스 규칙과 요구사항을 충족하는지에 더 초점을 맞춥니다.
- **예시**: "상품을 장바구니에 담으면 총액이 올바르게 계산되어야 한다"와 같은 사용자 요구사항을 기반으로 테스트합니다.

### 일반적인 테스트 순서

개발 과정에서 테스트는 보통 **좁은 범위에서 넓은 범위**로 진행됩니다.
**단위 테스트 → 통합 테스트 → E2E 테스트/인수 테스트**
이는 작은 단위부터 검증하여 문제를 빠르게 발견하고, 점진적으로 시스템 전체의 안정성을 확보하는 효과적인 방법입니다.

---

## NestJS 예제

NestJS는 기본적으로 Jest를 사용하여 테스트 환경을 구성합니다.

### 1. 단위 테스트 (Unit Test)

단위 테스트는 서비스(Service)나 컨트롤러(Controller) 등 하나의 모듈을 **독립적으로** 테스트합니다. 의존성(Dependency)은 `jest.mock` 등을 사용해 **가짜(mock) 객체**로 대체합니다.

**예제: `CatsService` 단위 테스트**

`cats.service.ts`

```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class CatsService {
  private readonly cats: string[] = ['Kitty', 'Paws'];

  findAll(): string[] {
    return this.cats;
  }
}
```

`cats.service.spec.ts` (테스트 파일)

```ts
import { Test } from '@nestjs/testing';
import { CatsService } from './cats.service';

describe('CatsService', () => {
  let service: CatsService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [CatsService],
    }).compile();

    service = module.get<CatsService>(CatsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should return all cats', () => {
    const cats = service.findAll();
    expect(cats).toEqual(['Kitty', 'Paws']);
  });
});
```

- **설명**: `Test.createTestingModule`을 사용해 `CatsService`만 포함하는 테스트 모듈을 만듭니다. `beforeEach` 블록에서 이 모듈을 컴파일하고 `CatsService` 인스턴스를 가져와서, `findAll` 메서드가 예상한 값을 반환하는지 테스트합니다.

### 2. E2E 테스트 (End-to-End Test)

E2E 테스트는 **실제 HTTP 요청**을 보내 전체 시스템의 동작을 확인합니다. NestJS는 `supertest` 라이브러리를 사용해 HTTP 요청을 쉽게 시뮬레이션할 수 있도록 도와줍니다.

**예제: `CatsController` E2E 테스트**

`cats.controller.ts`

```ts
import { Controller, Get } from '@nestjs/common';
import { CatsService } from './cats.service';

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Get()
  findAll(): string[] {
    return this.catsService.findAll();
  }
}
```

`cats.e2e-spec.ts` (테스트 파일)

```ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './app.module';

describe('CatsController (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/cats (GET)', () => {
    return request(app.getHttpServer())
      .get('/cats')
      .expect(200)
      .expect(['Kitty', 'Paws']);
  });

  afterAll(async () => {
    await app.close();
  });
});
```

- **설명**: `Test.createTestingModule`에 **전체 `AppModule`을 임포트**하여 실제 애플리케이션과 동일한 환경을 구성합니다. `supertest`를 사용해 `/cats` 엔드포인트로 `GET` 요청을 보내고, **HTTP 상태 코드(200)와 응답 본문(`['Kitty', 'Paws']`)이** 올바른지 검증합니다.

### 3. 통합 테스트 (Integration Test)

통합 테스트는 두 개 이상의 모듈이 함께 작동하는지 확인합니다. NestJS에서는 E2E 테스트와 유사한 방식으로 특정 모듈만 포함하는 테스트 모듈을 구성하여 수행합니다.

**예제: `CatsModule`과 `DatabaseModule` 통합 테스트 (가상의 예시)**

`cats.module.ts`

```ts
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { DatabaseModule } from '../database/database.module'; // 가상의 데이터베이스 모듈
import { catsProviders } from './cats.providers';

@Module({
  imports: [DatabaseModule], // 의존성 주입
  controllers: [CatsController],
  providers: [CatsService, ...catsProviders],
})
export class CatsModule {}
```

`cats.integration-spec.ts` (테스트 파일)

```ts
import { Test } from '@nestjs/testing';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { CatsModule } from './cats.module';

describe('CatsController (Integration)', () => {
  let controller: CatsController;
  let service: CatsService;

  beforeAll(async () => {
    const module = await Test.createTestingModule({
      imports: [CatsModule], // CatsModule 전체를 불러옵니다.
    })
    .overrideProvider(CatsService) // 필요한 경우 가짜 객체로 대체
    .useValue({ findAll: () => ['IntegrationTestCat'] })
    .compile();

    controller = module.get(CatsController);
    service = module.get(CatsService);
  });

  it('should call CatsService.findAll when CatsController.findAll is called', async () => {
    const serviceSpy = jest.spyOn(service, 'findAll');
    await controller.findAll();
    expect(serviceSpy).toHaveBeenCalled();
  });

  it('should return the correct value from the service', async () => {
    const result = await controller.findAll();
    expect(result).toEqual(['IntegrationTestCat']);
  });
});
```

- **설명**: `Test.createTestingModule`에 `CatsModule` 전체를 임포트하여, 컨트롤러와 서비스 간의 연동을 테스트합니다. 여기서는 `CatsService`의 실제 구현 대신 가짜 값을 사용해 **컨트롤러가 서비스를 올바르게 호출하는지**를 검증하는 데 초점을 맞춥니다. E2E 테스트가 전체 HTTP 흐름을 본다면, 통합 테스트는 모듈 간의 **내부 연동**에 집중하는 것입니다.

이 예시들은 NestJS의 테스트 기능을 활용해 각 테스트의 목적을 달성하는 방법을 보여줍니다.

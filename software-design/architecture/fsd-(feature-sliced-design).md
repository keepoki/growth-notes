---
tags:
  - Architecture
title: Feature Sliced Design
---
## 개요

**FSD(Feature-Sliced Design)** 는 프론트엔드 프로젝트를 **기능(Feature)** 위주로 나누어, 코드의 **응집도(Cohesion)** 를 높이고 **결합도(Coupling)** 를 낮추는 설계 방법론입니다.

이 구조의 핵심은 **3가지 계층 구조(Hierarchy)** 로 이루어져 있다는 점입니다.

### ① 레이어 (Layer): "책임의 단계"

프로젝트를 7개의 표준화된 층으로 나눕니다. 가장 중요한 규칙은 **"상위 레이어는 하위 레이어만 참조할 수 있다"** 는 단방향 의존성 규칙입니다.
1. **App:** 애플리케이션 진입점, 전역 설정 (Provider, Router).
2. **Pages:** 실제 화면 페이지의 조합.
3. **Widgets:** 페이지에 들어가는 독립적인 UI 블록 (Header, PostFeed).
4. **Features:** 사용자 상호작용/비즈니스 가치를 만드는 동작 (AddToCart, UserLogin).
5. **Entities:** 비즈니스 도메인 데이터 (User, Product, Order).
6. **Shared:** 특정 도메인에 속하지 않는 재사용 가능한 코드 (UI Kit, Utils).

### ② 슬라이스 (Slice): "비즈니스 도메인"

각 레이어 안에서 **주제(도메인)**별로 폴더를 나눕니다.
- 예: `features/login`, `features/search`, `entities/user`, `entities/product`
- **규칙:** 슬라이스끼리는 서로 직접 참조할 수 없습니다. (높은 응집도 유지)

### ③ 세그먼트 (Segment): "기술적 역할"

슬라이스 내부를 코드의 성격에 따라 나눕니다.
- `ui` (컴포넌트), `model` (상태/로직), `api` (서버 통신), `lib` (유틸리티).

---

## 비유: "초대형 햄버거 가게 운영하기"

네가 친구들과 함께 학교 축제에서 **초대형 수제 햄버거 가게**를 열었다고 상상해 봐. 처음엔 너 혼자 다 만들었지만, 장사가 너무 잘 돼서 직원이 100명이 되었어. 재료랑 도구가 섞여서 난리가 났지.

그래서 너는 주방을 **"절대 섞이면 안 되는 6개의 선반"** 으로 완벽하게 정리하기로 했어. 이것이 바로 FSD야.

### 🏢 1. 레이어 (Layer): 6단 정리 선반

이 선반에는 절대적인 규칙이 있어. **"위 칸에 있는 물건을 만들 때, 아래 칸에 있는 재료는 써도 되지만, 아래 칸 사람이 위 칸 물건을 가져갈 순 없다."** (중력의 법칙!)

- **1층: Shared (공용 창고)** 🧂🔪
    - **설명:** 소금, 후추, 칼, 도마, 행주.
    - 어떤 햄버거를 만들든, 누가 요리하든 무조건 쓰는 가장 기본적인 도구들이야.
    - _(코드: 버튼, 아이콘, 날짜 계산기)_
- **2층: Entities (재료 준비실)** 🥩🥬🧀
    - **설명:** 다듬어진 패티, 씻은 양상추, 슬라이스 치즈.
    - 이것들은 그냥 '재료' 그 자체야. 아직 요리된 건 아니고, 햄버거의 주인공들이지.
    - _(코드: 사용자 정보, 상품 데이터, 장바구니 데이터)_
- **3층: Features (조리 기술)** 🍳💸
    - **설명:** "고기 굽기", "감자 튀기기", "돈 계산하기".
    - 재료(2층)와 도구(1층)를 사용해서 실제로 **'행동'** 을 하는 곳이야.
    - _(코드: 장바구니 담기 기능, 로그인 기능, 결제 기능)_
- **4층: Widgets (세트 메뉴판)** 🍱
    - **설명:** 햄버거 + 감자튀김 + 콜라를 묶어서 쟁반 하나에 담은 것.
    - 손님에게 나가기 직전의 완성된 덩어리야.
    - _(코드: 헤더, 상품 리스트, 결제 창)_
- **5층: Pages (식탁/테이블)** 🍽️
    - **설명:** 손님이 앉는 테이블.
    - 여기엔 세트 메뉴(4층)도 놓고, 휴지(1층)도 놓고, 계산서도 놓아서 식사 준비를 끝내는 곳이야.
    - _(코드: 메인 페이지, 로그인 페이지, 주문 내역 페이지)_
- **6층: App (가게 전체)** 🏠
    - **설명:** 가게 간판 달고, 문 열고, 에어컨 켜는 것. 가게 운영의 시작!
    - _(코드: Next.js 설정, 라우터, 글로벌 스타일)_

### 🍰 2. 슬라이스 (Slice): 재료별 바구니

2층(재료 준비실)에 갔는데 고기랑 야채가 섞여 있으면 안 되겠지? 그래서 바구니를 따로 둬.
- **`고기` 바구니:** 소고기 패티, 닭고기 패티 (다른 바구니랑 섞이지 않음!)
- **`야채` 바구니:** 양상추, 토마토, 피클

FSD에서는 이걸 **"기능별로 폴더를 나눈다"**고 해. `User(사용자)` 폴더 안에는 사용자 관련 코드만 넣고, `Product(상품)` 폴더와 섞지 않는 거야.

### 🔪 3. 세그먼트 (Segment): 바구니 안의 칸막이

`고기` 바구니 안에서도 더 깔끔하게 나누고 싶어.
- **모양 담당:** 고기가 동그란지 네모난지 (UI)
- **맛 담당:** 고기에 간이 되어 있는지 (Model/Logic)
- **공급 담당:** 고기를 어디서 사 오는지 (API)

### 가장 중요한 규칙: "중력의 법칙"

FSD에는 절대 어겨선 안 되는 **단 하나의 절대 규칙**이 있습니다. 바로 **"위에서 아래로만 가져다 쓸 수 있다"** 는 것입니다.

- **가능 (O):**
    - **건물(Widgets)** 을 지을 때 **기본 벽돌(Shared)** 을 가져다 쓴다. (당연하죠?)
    - **완성된 장면(Pages)** 에 **건물(Widgets)** 을 배치한다.
- **불가능 (X):**
    - **기본 벽돌(Shared)** 을 만드는데 **경찰서 건물(Widgets)** 을 집어넣는다? -> **말이 안 됨!**
    - **경찰관 피규어(Entities)** 안에 **다운타운(Pages)** 전체를 넣는다? -> **물리적으로 불가능!**

이 규칙 덕분에 코드가 꼬이지 않고, 나중에 "어? 이 벽돌 빼면 도시가 무너지나?" 하고 걱정할 필요가 없어집니다. 밑에 있는 건 위에 있는 걸 절대 모르니까요!

---

## Next.js 폴더 구조 예시

이커머스(쇼핑몰)을 예시로 Next.js App Router에 맞춘 FSD 폴더 구조는 다음과 같습니다.

```bash
root/
├── public/                 # 정적 파일 (이미지, 폰트)
├── src/
│   # ------------------------------------------------------------------
│   # 1. App Layer (Next.js 진입점 & 전역 설정)
│   # ------------------------------------------------------------------
│   ├── app/                # Next.js App Router (라우팅 역할만 수행)
│   │   ├── (shop)/         # 상점 관련 라우트 그룹
│   │   │   ├── page.tsx    # 메인 페이지 -> src/pages/home/ui/Page.tsx 불러옴
│   │   │   └── product/
│   │   │       └── [id]/
│   │   │           └── page.tsx # 상품 상세 -> src/pages/product-detail/...
│   │   ├── layout.tsx      # RootLayout (Providers, Global Styles)
│   │   └── providers.tsx   # React Query, Recoil 등 전역 Provider
│   │
│   # ------------------------------------------------------------------
│   # 2. Pages Layer (페이지 단위 조합)
│   # - app 디렉토리의 page.tsx에서 여기를 import 해서 렌더링
│   # ------------------------------------------------------------------
│   ├── pages/
│   │   ├── home/           # 메인 페이지
│   │   │   └── ui/
│   │   │       └── Page.tsx
│   │   ├── product-detail/ # 상품 상세 페이지
│   │   ├── cart/           # 장바구니 페이지
│   │   └── checkout/       # 결제 페이지
│   │
│   # ------------------------------------------------------------------
│   # 3. Widgets Layer (독립적인 큰 UI 블록)
│   # - Header, Footer, ProductList 등 페이지를 구성하는 덩어리
│   # ------------------------------------------------------------------
│   ├── widgets/
│   │   ├── header/         # 헤더 (로고 + 검색창 + 장바구니 아이콘 조합)
│   │   │   └── ui/
│   │   │       └── Header.tsx
│   │   ├── product-list/   # 상품 리스트 (ProductCard의 반복 나열)
│   │   └── cart-summary/   # 장바구니 요약 정보 창
│   │
│   # ------------------------------------------------------------------
│   # 4. Features Layer (사용자 상호작용/기능)
│   # - "동사" 개념. 사용자가 수행하는 액션 (검색, 담기, 결제하기)
│   # ------------------------------------------------------------------
│   ├── features/
│   │   ├── add-to-cart/    # [기능] 장바구니 담기 (버튼 + API 로직)
│   │   │   ├── ui/         # AddToCartButton.tsx
│   │   │   ├── model/      # 장바구니 담기 상태/로직 (useAddToCart)
│   │   │   └── api/        # 장바구니 추가 API
│   │   ├── search-product/ # [기능] 상품 검색
│   │   ├── auth-login/     # [기능] 로그인 폼 및 로직
│   │   └── filter-products/# [기능] 카테고리/가격 필터링
│   │
│   # ------------------------------------------------------------------
│   # 5. Entities Layer (비즈니스 도메인 데이터/표시)
│   # - "명사" 개념. 데이터 그 자체와 데이터를 보여주는 카드 (순수함수)
│   # ------------------------------------------------------------------
│   ├── entities/
│   │   ├── product/        # [도메인] 상품
│   │   │   ├── ui/         # ProductCard.tsx (데이터만 보여줌, 버튼 로직 없음)
│   │   │   ├── model/      # 상품 타입 정의 (interface Product), 스토어
│   │   │   └── api/        # 상품 불러오기 API
│   │   ├── user/           # [도메인] 사용자
│   │   ├── cart/           # [도메인] 장바구니 (장바구니 아이템 타입 등)
│   │   └── order/          # [도메인] 주문
│   │
│   # ------------------------------------------------------------------
│   # 6. Shared Layer (공용 재사용 코드)
│   # - 비즈니스 로직이 없는 순수 UI, 유틸리티
│   # ------------------------------------------------------------------
│   └── shared/
│       ├── ui/             # 버튼, 인풋, 모달 (Design System)
│       ├── api/            # Axios 인스턴스, Fetch Wrapper
│       ├── lib/            # utils (날짜 포맷팅, 화폐 단위 변환)
│       └── config/         # 환경변수, 상수
│
├── .env
├── next.config.js
└── package.json
```

### 계층별 상세 설명 (이커머스 예시)

FSD의 핵심은 **"상위 레이어는 하위 레이어만 import 할 수 있다"** 는 규칙입니다. (App > Pages > Widgets > Features > Entities > Shared)

#### 1. Shared (최하위 레이어)
이곳은 비즈니스 로직(쇼핑몰 관련 내용)이 전혀 없는 곳입니다.
- **예시:** `Button.tsx` (그냥 스타일만 있는 버튼), `formatPrice(number)` (숫자를 '10,000원'으로 바꿔주는 함수).
- 이 버튼은 로그인에도 쓰이고, 결제에도 쓰이고, 장바구니에도 쓰입니다.

#### 2. Entities (비즈니스 데이터)
쇼핑몰의 핵심 데이터인 '상품', '유저'를 정의합니다. **"보여주는 것"**에 집중합니다.
- **`entities/product`**:
    - `model`: 상품 데이터 타입 (`id`, `name`, `price`, `imageUrl`) 정의.
    - `ui/ProductCard.tsx`: 상품 이미지와 가격을 보여주는 카드 컴포넌트. (단, 여기에 '장바구니 담기' 버튼 기능은 넣지 않습니다! 그건 Feature입니다.)

#### 3. Features (사용자 기능/액션)
사용자가 웹사이트에서 **"무언가를 하는"** 기능입니다. 비즈니스 가치를 만듭니다.
- **`features/add-to-cart`**:
    - `ui/AddToCartButton.tsx`: 클릭하면 API를 호출해 장바구니에 물건을 넣는 버튼.
    - `api`: 실제 백엔드 장바구니 추가 API 통신 로직.
- **`features/product-filter`**: 가격대별, 색상별로 상품을 거르는 로직과 UI.

#### 4. Widgets (UI 조립)
Entities와 Features를 합쳐서 하나의 완성된 구역을 만듭니다.
- **`widgets/product-list`**:
    - `entities/product`의 `ProductCard`를 가져옵니다.
    - `features/add-to-cart`의 `AddToCartButton`을 가져옵니다.
    - 이 둘을 조합해서 "장바구니 버튼이 있는 상품 리스트"를 완성합니다.

#### 5. Pages (페이지 구성)
Widgets를 배치하여 화면 하나를 완성합니다.
- **`pages/home`**:
    - `widgets/header`, `widgets/banner`, `widgets/product-list`를 import 해서 차례대로 배치합니다.

#### 6. App (Next.js 라우팅)
- **`app/page.tsx`**: 단순히 `src/pages/home`을 import 해서 렌더링만 합니다.

---

## FSD를 적용할 때의 핵심 팁

1. **Entities vs Features 구분하기 (가장 중요)**
    - `ProductCard`에 "장바구니 담기 버튼"을 넣고 싶을 때 고민이 됩니다.
    - FSD에서는 `Entities/ProductCard`는 **보여주기만** 하고, `Features/AddToCartButton`을 **Slot(props)** 으로 주입받거나, `Widgets` 레벨에서 둘을 조합하는 것을 권장합니다. 그래야 `ProductCard`를 관리자 페이지(장바구니 기능 없음)에서도 재사용할 수 있기 때문입니다.
2. **Next.js App Router와의 타협**
    - FSD 공식 문서에서는 `app` 폴더가 최상위지만, Next.js의 `app` 폴더는 라우팅 규칙을 가지므로, **실제 로직은 `src/pages` (또는 `src/views`)에 두고 `src/app`은 껍데기로만 사용**하는 패턴이 가장 관리가 쉽습니다.
3. **과도한 분리는 금물**
    - 처음부터 모든 것을 완벽하게 쪼개려 하지 마세요. 처음에는 `features`에 뭉뚱그려 놓았다가, 재사용성이 필요해지면 `entities`나 `shared`로 내리는 방식이 좋습니다.
